{"meta":{"title":"清风揽月的Blog","subtitle":"","description":"","author":"清风揽月","url":"https://houyang99.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-02-14T11:22:16.314Z","updated":"2021-02-14T11:22:16.314Z","comments":true,"path":"404.html","permalink":"https://houyang99.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-02-29T19:58:47.000Z","updated":"2021-02-14T11:22:16.341Z","comments":true,"path":"categories/index.html","permalink":"https://houyang99.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-29T19:49:33.000Z","updated":"2021-02-14T11:22:16.341Z","comments":true,"path":"about/index.html","permalink":"https://houyang99.github.io/about/index.html","excerpt":"","text":"求知若渴,虚心若愚 学生一枚，平时无聊就爱乱捣鼓。。。"},{"title":"我的朋友们","date":"2021-02-14T11:22:16.342Z","updated":"2021-02-14T11:22:16.342Z","comments":true,"path":"friends/index.html","permalink":"https://houyang99.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-02-29T19:45:36.000Z","updated":"2021-02-14T11:22:16.342Z","comments":true,"path":"tags/index.html","permalink":"https://houyang99.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"序列化与反序列化简单案例","slug":"序列化与反序列化简单案例","date":"2020-08-09T12:58:35.000Z","updated":"2021-02-14T11:22:16.336Z","comments":true,"path":"2020/08/09/序列化与反序列化简单案例/","link":"","permalink":"https://houyang99.github.io/2020/08/09/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/","excerpt":"序列化与反序列化 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。——百度百科 简单点来说，序列化就是将一个存在在内存当中的一个对象转化为一个可以存储的二进制数据，以便用来进行数据传输或者保存，那么，反序列化就是将一个序列化后的某个数据再转化为对象的过程。 假如有一个Person类： 1234567891011121314class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"姓名：\" + this.name + \"、年龄：\" + this.age; &#125;&#125; 现在，我可以通过 new 关键字来实例化一个对象 1Person person = new Person(\"张三\", 20); 这样，我们就可以创建（实例化）一个对象了，但是，如果我需要将这个对象保存起来呢？该如何实现？","text":"序列化与反序列化 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。——百度百科 简单点来说，序列化就是将一个存在在内存当中的一个对象转化为一个可以存储的二进制数据，以便用来进行数据传输或者保存，那么，反序列化就是将一个序列化后的某个数据再转化为对象的过程。 假如有一个Person类： 1234567891011121314class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"姓名：\" + this.name + \"、年龄：\" + this.age; &#125;&#125; 现在，我可以通过 new 关键字来实例化一个对象 1Person person = new Person(\"张三\", 20); 这样，我们就可以创建（实例化）一个对象了，但是，如果我需要将这个对象保存起来呢？该如何实现？ Serializable 接口当一个类实现了Serializable接口，不用实现任何方法，该类的对象就是可以序列化的。 下面，我们对Person类进行改造，使Person类的对象可以被序列化： 1234567891011121314class Person implements Serializable &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return \"姓名：\" + this.name + \"、年龄：\" + this.age; &#125;&#125; 我们仅仅追加了 implements Serializable ，除此之外，没有添加任何的东西，Person类便可以被序列化。 ObjectInputStream / ObjectOutputStream 对象输入/输出流既然要将一个对象保存起来或者是从文件读取，那么就要使用到ObjectInputStream / ObjectOutputStream 对象输入/输出流进行保存与读取。 类 主要方法 主要方法说明 ObjectInputStream readObject() 反序列化（读取一个序列化对象） ObjectOutputStream writeObject(obj) 序列化（将对象以流的形式写出到硬盘上的某个文件） 序列化一个对象123456789public static void main(String[] args) throws Exception &#123; // 创建一个File对象保存序列化后的对象 File file = new File(\"D:\" + File.separator + \"person.ser\"); Person person = new Person(\"张三\", 20); // ObjectOutputStream构造器接受一个FileOutputStream对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(obj); // 序列化 oos.close(); &#125; 运行后，D盘会生成一个person.ser的二进制文件。 反序列化1234567public static void main(String[] args) throws Exception &#123; File file = new File(\"D:\" + File.separator + \"person.ser\"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); Object obj = ois.readObject(); // 反序列化 System.out.println(obj); // 输出 ois.close(); &#125; 运行后输出person.ser反序列化后的对象信息：","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://houyang99.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"Java","slug":"Java","permalink":"https://houyang99.github.io/tags/Java/"}]},{"title":"无限连载小说之大水比","slug":"无限连载小说之大水比","date":"2020-07-17T09:58:39.000Z","updated":"2021-02-14T11:22:16.337Z","comments":true,"path":"2020/07/17/无限连载小说之大水比/","link":"","permalink":"https://houyang99.github.io/2020/07/17/%E6%97%A0%E9%99%90%E8%BF%9E%E8%BD%BD%E5%B0%8F%E8%AF%B4%E4%B9%8B%E5%A4%A7%E6%B0%B4%E6%AF%94/","excerpt":"","text":"无限连载小说之大水比前言笔者生活中在一个充满各种奇迹的世界上，见过非常多的奇迹，新认识了非常多的词汇，现将这些奇闻趣事一一分享出来，也让这些奇闻趣事不石沉大海！ 第一章 钓鱼佬未时昂公刺肚​ 午时，一群钓鱼佬三人便前往一条有着各路神仙的小溪流，准备捉拿一些神兽，一人轻装上阵，一人满腹武装，蓄势待发，准备大战一场，一人骑着战马，带长剑若干。一同来到了这条小溪的一边，布上法阵，手持长剑。准备充足之后，三人纷纷施法，便将长剑架起，等待各种神兽前来。 ​ 突然，其中一人的长剑便感应到了神兽，那人便拿起长剑，使出收兽之术，手一提，那神兽便被长剑的强大束缚力所困住，不知道是施法过度还是受到了神兽的反击，竟被一黄色带有利刺的神兽所刺到肚子，霎时，那人便屏住丹田，双手护住伤口，似笑非笑，似哭非哭，好生刺激，便引来旁边两人的注意，此时，两人便拿起记录时光的法器，记下了此时的那刻。片刻之后，便又开始进行守株待兔的等待…… 第二章 钓鱼佬爆护之回家遭暗算未完待续……","categories":[],"tags":[{"name":"喜闻乐见","slug":"喜闻乐见","permalink":"https://houyang99.github.io/tags/%E5%96%9C%E9%97%BB%E4%B9%90%E8%A7%81/"},{"name":"日常水","slug":"日常水","permalink":"https://houyang99.github.io/tags/%E6%97%A5%E5%B8%B8%E6%B0%B4/"}]},{"title":"单例设计模式是个什么东西？","slug":"单例设计模式是个什么东西","date":"2020-03-18T10:36:14.000Z","updated":"2021-02-14T11:22:16.334Z","comments":true,"path":"2020/03/18/单例设计模式是个什么东西/","link":"","permalink":"https://houyang99.github.io/2020/03/18/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/","excerpt":"在学习Java的过程中，各种设计模式便扑面而来，笔者目前便接触到了单例设计模式，与之对应的还有多例设计模式。下面便奉上个人的领悟（笔者也只是个初入Java的学习者，如有错误也是在所难免的）。 什么是单例设计模式单例设计模式，重点就在这个”单“上，指的是一个类只能实例化一个对象。 假设现在有一个Singleton类： 123456class Singleton &#123; public Singleton() &#123;&#125;; public void hello() &#123; System.out.println(\"Hello !\"); &#125;&#125; 一般情况下，我们都是直接通过new关键字来获得一个实例化对象 1Singleton s = new Singleton(); 可是如果能够new出一个实例化对象，那么一定可以再new出更多的实例化对象，显然是不符合单例设计模式的要求的。因此我们需要将类的设计做一些改变，使之不能被直接new出来，所以我们将类的构造方法设为私有化的，即为： 1private Singleton() &#123;&#125;;","text":"在学习Java的过程中，各种设计模式便扑面而来，笔者目前便接触到了单例设计模式，与之对应的还有多例设计模式。下面便奉上个人的领悟（笔者也只是个初入Java的学习者，如有错误也是在所难免的）。 什么是单例设计模式单例设计模式，重点就在这个”单“上，指的是一个类只能实例化一个对象。 假设现在有一个Singleton类： 123456class Singleton &#123; public Singleton() &#123;&#125;; public void hello() &#123; System.out.println(\"Hello !\"); &#125;&#125; 一般情况下，我们都是直接通过new关键字来获得一个实例化对象 1Singleton s = new Singleton(); 可是如果能够new出一个实例化对象，那么一定可以再new出更多的实例化对象，显然是不符合单例设计模式的要求的。因此我们需要将类的设计做一些改变，使之不能被直接new出来，所以我们将类的构造方法设为私有化的，即为： 1private Singleton() &#123;&#125;; 这还不够，我们还需要在类的内部提供一个static的属性以及方法，用于保存实例化之后的对象以及提供给外部获取此对象的方法。于是整个类的设计为： 123456789101112class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; return instance; &#125; public void hello() &#123; System.out.println(\"Hello !\"); &#125;&#125; 此时，我们尝试来new一下类 12345public class Demo &#123; public static void main(String args[]) &#123; Singleton s = new Singleton(); &#125;&#125; 使用javac命令编译以后，便直接报错： 可以看到，现在是不能够通过new关键字来实例化一个对象了。我们应该通过类的静态方法获得类的实例 123456public class Demo &#123; public static void main(String args[]) &#123; Singleton s = Singleton.getInstance(); s.hello(); &#125;&#125; 编译并执行 可以看到，编译成功并且执行了方法hello()。 到此，一个基本的单例设计模式便完成了，我们把上面这种实现方式也称为饿汉式。饿汉式在类加载时就会实例化对象，因此，在多线程的情况下，可能会出现同步问题。因此，还有一种方式称为懒汉式： 123456789101112131415class Singleton &#123; private static Singleton instance = null; private Singleton() &#123;&#125;; public static synchronized Singleton getInstance() &#123; // 使用synchronized修饰方法使之同步 if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; public void hello() &#123; System.out.println(\"Hello !\"); &#125;&#125; 然而，synchronized修饰的方法在执行效率上通常较低，所以最好的办法是使用双重校验锁（DCL double-checked locking） 12345678910111213141516171819class Singleton &#123; private static Singleton instance = null(); private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; if(instance == null) &#123; synchronized(Singleton.class) &#123; if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public void hello() &#123; System.out.println(\"Hello !\"); &#125;&#125; END!","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://houyang99.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"Java","slug":"Java","permalink":"https://houyang99.github.io/tags/Java/"}]},{"title":"Java I/O 学习笔记","slug":"Java-IO-学习笔记-上","date":"2020-02-29T11:52:55.000Z","updated":"2021-02-14T11:22:16.317Z","comments":true,"path":"2020/02/29/Java-IO-学习笔记-上/","link":"","permalink":"https://houyang99.github.io/2020/02/29/Java-IO-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%8A/","excerpt":"Java I/OI/O 文件对象创建一个文件对象File f = new File(&quot;d:/test&quot;); 文件对象常用方法123456789101112131415161718f.exists() //文件是否存在f.isDirectory() //是否是文件夹f.isFile(); //是否是文件f.length(); //文件长度f.lastModified() //文件最后修改时间f.renameTo(File Object); //文件重命名，参数为文件对象f.list(); //以字符串数组形式返回当前文件夹下所有文件f.ListFiles(); //以文件数组形式返回……f.getParent(); //返回父文件夹（一般相对于文件） --字符串形式f.getParentFile(); //同上 --文件形式f.mkdir(); //创建文件夹（父文件夹不存在，创建无效）f.mkdirs(); //创建文件夹，父文件夹不存在则会创建父文件夹f.creatNewFile(); //创建一个空文件，父文件夹不存在则会抛出异常f.getParentFile().mkdirs(); //创建空文件时，通常会创建父目录f.listRoots(); //列出根目录（Windows下列出盘符）f.delete(); //删除文件f.deleteOnExit(); //JVM结束时删除文件，常用于删除临时文件","text":"Java I/OI/O 文件对象创建一个文件对象File f = new File(&quot;d:/test&quot;); 文件对象常用方法123456789101112131415161718f.exists() //文件是否存在f.isDirectory() //是否是文件夹f.isFile(); //是否是文件f.length(); //文件长度f.lastModified() //文件最后修改时间f.renameTo(File Object); //文件重命名，参数为文件对象f.list(); //以字符串数组形式返回当前文件夹下所有文件f.ListFiles(); //以文件数组形式返回……f.getParent(); //返回父文件夹（一般相对于文件） --字符串形式f.getParentFile(); //同上 --文件形式f.mkdir(); //创建文件夹（父文件夹不存在，创建无效）f.mkdirs(); //创建文件夹，父文件夹不存在则会创建父文件夹f.creatNewFile(); //创建一个空文件，父文件夹不存在则会抛出异常f.getParentFile().mkdirs(); //创建空文件时，通常会创建父目录f.listRoots(); //列出根目录（Windows下列出盘符）f.delete(); //删除文件f.deleteOnExit(); //JVM结束时删除文件，常用于删除临时文件 Stream 流 Java使用流在不同介质之间进行数据交换。 流分为输入流(InputStream)和输出流(OutputStream) 文件输入流( FileInputStream )123//创建一个文件，并创建一个基于此文件的输入流（实现数据的读取）File f = new File(\"d:/test.txt\");FileInputStream fis = new FileInputStream(f); 文件输入流( FileOutputStream )123//创建一个文件，并创建一个基于此文件的输出流（实现数据的读取）File f = new File(\"d:/test.txt\");FileOutputStream fis = new FileOutputStream(f); 字节流 以字节的形式读取和写入文件 字节输入流 InputStream 字节输出流 OutputStream 以字节形式读取文件内容 123456File f = new File(\"d:/test.txt\");FileInputStream fis = new FileInputStream(f);byte[] data = new byte[(int)f.length()];//以字节的形式读取所有内容fis.read(data);fis.close(); 以字节形式写入文件内容123456File f = new File(\"d:/test.txt\");byte data[] = &#123;'H','e','l','l','o',',','W','o','r','l','d','!'&#125;;FileOutputStream fos = new FileOutputStream(f);//把数据写入到输出流fos.write(data);fos.close(); 案例 拆分文件 拆分的对象是一首歌，拆分后每份文件的大小为500KB。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Arrays;public class Test &#123; public static void main(String[] args) &#123; int size = 500 * 1024; File mp3 = new File(\"c:/test/dnf.mp3\"); splitFile(mp3, size); &#125; /** * 拆分文件，按字节拆分 * @param file 要拆分的文件对象 * @param size 拆分文件的平均大小(字节) */ public static void splitFile(File file, int size) &#123; if(0 == file.length()) throw new RuntimeException(\"文件长度为0，不可拆分\"); String fileName = file.getName(); int netIndex = fileName.indexOf(\".\"); String suffix = fileName.substring(netIndex, fileName.length()); byte[] fileContent = new byte[(int)file.length()]; try &#123; FileInputStream fis = new FileInputStream(file); fis.read(fileContent); fis.close(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; int fileNumber = (int)Math.ceil((double)fileContent.length / size); System.out.println(\"文件大小为：\" + file.length() + \"字节\"); System.out.println(\"拆分为\" + fileNumber + \"个文件\"); for(int i=0; i&lt;fileNumber; i++) &#123; String newFileName = fileName.substring(0, netIndex) + \"_\" + i + suffix; File f_temp = new File(file.getParent(), newFileName); byte[] tempContent; if(i &lt; fileNumber - 1) &#123; tempContent = Arrays.copyOfRange(fileContent, size * i, size * (i + 1)); &#125;else &#123; tempContent = Arrays.copyOfRange(fileContent, size * i, fileContent.length); &#125; try &#123; FileOutputStream fos = new FileOutputStream(f_temp); fos.write(tempContent); fos.close(); System.out.printf(\"文件：%s\\t大小：%d字节\\n\",f_temp.getAbsolutePath(), tempContent.length); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 合并文件 将上文拆分的文件合并为一个新文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class Test &#123; public static void main(String[] args) &#123; /** * mergeFiles(String [目标文件夹], String [合成后的文件名], String [要合并的文件名]); * String [要合并的文件名] 例如 a_1.mp3 a_2.mp3 则只需要传入a.mp3即可 */ mergeFiles(\"c:/test\", \"new_dnf.mp3\", \"dnf.mp3\"); &#125; private static void mergeFiles(String folder, String destName, String fileName) &#123; File destFile = new File(folder,destName); try &#123; FileOutputStream fos = new FileOutputStream(destFile); int index = 0; while(true) &#123; File eachFile = new File(folder, fileName.substring(0, fileName.indexOf(\".\")) + \"_\" + index + \".mp3\"); if(!eachFile.exists()) &#123; break; &#125; FileInputStream fis = new FileInputStream(eachFile); byte[] eachContent = new byte[(int)eachFile.length()]; fis.read(eachContent); fis.close(); fos.write(eachContent); fos.flush(); System.out.println(\"文件：\" + eachFile + \"写入到了文件：\" + destFile); index++; &#125; fos.close(); System.out.println(\"写入成功！文件大小：\" + destFile.length()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 关闭流 所有的流在使用完毕之后，都应该关闭，以释放资源。 如果不关闭，则会导致对资源的占用以及浪费，影响业务的开展。 方法一：在try中关闭 此种方法存在隐患 如果文件不存在或者读取时发生异常，导致抛出了异常，则不会进行关闭 12345678910try&#123; File f = new File(\"d:/test.txt\"); FileInputStream fis = new FileInputStream(f); byte[] data = new byte[(int) f.length()]; fis.read(data); for (byte b: data) &#123; System.out.println(b); &#125; fis.close();&#125; 方法二：在finally中关闭 标准的关闭方式 流的声明应在try外面，否则作用域无法抵达finally 关闭流时应进行判空处理并再次进行try catch处理 1234567891011121314151617181920212223File f = new File(\"d:/test.txt\");FileInputStream fis = null;try &#123; fis = new FileInputStream(f); byte[] data = new byte[(int) f.length()]; fis.read(data); for (byte b: data) &#123; System.out.println(b); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; if (null != fis)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 方法三：使用带资源的try语句（try-with-resource） JDK7中新增 try-with-resource 语法糖来打开资源，而无需手动关闭和回收相关资源。 12345678910File f = new File(\"d:/test.txt\");try (FileInputStream fis = new FileInputStream(f)) &#123; byte[] data = new byte[(int) f.length()]; fis.read(data); for (byte b: data) &#123; System.out.println(b); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125;","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://houyang99.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"Java","slug":"Java","permalink":"https://houyang99.github.io/tags/Java/"}]},{"title":"写的一个扫雷简单版","slug":"写的一个扫雷简单版","date":"2019-11-29T13:14:14.000Z","updated":"2021-02-14T11:22:16.330Z","comments":true,"path":"2019/11/29/写的一个扫雷简单版/","link":"","permalink":"https://houyang99.github.io/2019/11/29/%E5%86%99%E7%9A%84%E4%B8%80%E4%B8%AA%E6%89%AB%E9%9B%B7%E7%AE%80%E5%8D%95%E7%89%88/","excerpt":"JavaScript 扫雷[简单版]目前迭代了两个版本，一个是最开始的初始版，一个是截止到发文之时的一个改进版。此文也将继续更新每个版本的迭代过程。 点击右下角选择最后可以进行试玩 试玩 第一版界面以表格为载体呈现，通过创建一个和表格行数和列数相等的数组， 随机生成若干组随机数，取值为0到数组的最大下标-1，然后将其以数组的下标，在数组对应的位置赋值为1，其他的地方为0，后面以1为雷，0为安全的格子。 效果： 初始界面⬇","text":"JavaScript 扫雷[简单版]目前迭代了两个版本，一个是最开始的初始版，一个是截止到发文之时的一个改进版。此文也将继续更新每个版本的迭代过程。 点击右下角选择最后可以进行试玩 试玩 第一版界面以表格为载体呈现，通过创建一个和表格行数和列数相等的数组， 随机生成若干组随机数，取值为0到数组的最大下标-1，然后将其以数组的下标，在数组对应的位置赋值为1，其他的地方为0，后面以1为雷，0为安全的格子。 效果： 初始界面⬇ 点击样式⬇ 点到雷的提示⬇ 点击提示的确定后会显示： 主要思路： 先有一个10x10的表格` 创建一个数组(10行10列)` 使用循环将数组所有值赋值为0` 使用随机数生成10对[0，10]之间的数作为数组的下标，将数组下标为其的值赋值为1` 为每一个表格节点添加一个input节点，并且设置其属性，设置单击事件的属性为带x,y坐标值的isBoom(x,y)函数` 把x,y作为数组下标在数组里获取对应的值，如果为1，则为雷，如果为0，则将其周围类的个数显示在对应的格子里` 代码HTML5+CSS部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;扫雷&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; h2&#123; text-align: center; padding-top: 20px; &#125; table&#123; margin: 50px auto 0 auto; text-align: center; width: 450px; height: 450px; &#125; #operat&#123; display: flex; justify-content: center; width: 450px; margin: 10px auto; /* border: 1px solid #000; */ &#125; .operat&#123; background-color: red; margin: 0 auto; width: 50px; height: 30px; &#125; input&#123; width: 100%; height: 100%; border: none; &#125; td&#123; width: 10px; height: 10px; &#125; .safe&#123; background-color: limegreen; color: #fff; &#125; .bomb&#123; background-color: darkred; &#125; .displayAll&#123; background-color: darkorange; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;扫雷&lt;/h2&gt; &lt;table border=\"1\" id=\"tab\"&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;div id=\"operat\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; JavaScript部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;script type=\"text/javascript\"&gt; var opera = document.getElementById('operat'); var btn1 = document.createElement('input'); var btn2 = document.createElement('input'); //没有雷的格子数量 var notBoomNum = 0; var x = 0; var y = 0; //正方形表格的边的格子数 var edgeLattice = 10; //雷的数量 var boomNum = 20; // 用于存放雷的数组 var boomArray = new Array(edgeLattice); var XLen = 0; var YLen = 0; for (var i = 0; i &lt; boomArray.length; i++) &#123; boomArray[i] = new Array(10); &#125; XLen = boomArray[0].length; YLen = boomArray.length; notBoomNum = (XLen * YLen) - boomNum; console.log(\"共\" + XLen * YLen + \"个格子\"); console.log(\"一共有\" + boomNum + \"个雷\"); //初始化雷的个数 setBoom(); createOperat(); opera.appendChild(btn1); console.log(boomArray); var allRow = document.getElementsByTagName('tr'); for (var i = 0; i &lt; YLen; i++) &#123; for (var j = 0; j &lt; XLen; j++) &#123; var thisBtn = document.createElement('input'); thisBtn.setAttribute(\"type\", \"button\"); thisBtn.setAttribute(\"value\", \" \"); thisBtn.setAttribute(\"onclick\", \"isBoom(\" + i + \",\" + j + \")\"); allRow[i].children[j].appendChild(thisBtn); &#125; &#125; function setBoom() &#123; var count = 0; var x = 0; var y = 0; for (var i = 0; i &lt; boomArray.length; i++) &#123; for (var j = 0; j &lt; boomArray[i].length; j++) &#123; boomArray[i][j] = 0; &#125; &#125; //随机数生成boomNum个雷 while (count &lt; boomNum) &#123; x = Math.ceil(Math.random() * (YLen)) - 1; y = Math.ceil(Math.random() * (XLen)) - 1; //防止类的位置重复 if (boomArray[x][y] == 0) &#123; boomArray[x][y] = 1; count++; &#125; &#125; &#125; function isBoom(x, y) &#123; var td = boomArray[x][y]; if (td != 1) &#123; notBoomNum--; console.log(notBoomNum); showBoom(x, y); if (notBoomNum == 0) &#123; alert(\"恭喜您，成功通关！\"); location.reload(); &#125; &#125; else &#123; alert(\"BOOM!!! Game Over！\"); showAllTd(); // showAllBoom(); // location.reload(); &#125; &#125; function showBoom(x, y) &#123; var num = 0; if (x == 0) &#123; if (y == 0) num = boomArray[0][1] + boomArray[1][1] + boomArray[1][0]; else if (y == boomArray[x].length - 1) num = boomArray[0][y - 1] + boomArray[x + 1][y - 1] + boomArray[x + 1][y]; else &#123; num = boomArray[x][y - 1] + boomArray[x + 1][y - 1] + boomArray[x + 1][y] + boomArray[x + 1][y + 1] + boomArray[x] [y + 1]; &#125; mySet(x, y, num); console.log(num); &#125; if (x == (boomArray.length - 1)) &#123; if (y == 0) num = boomArray[x - 1][0] + boomArray[x - 1][1] + boomArray[x][y + 1]; else if (y == boomArray[x].length - 1) num = boomArray[x][y - 1] + boomArray[x - 1][y - 1] + boomArray[x - 1][y]; else &#123; num = boomArray[x][y - 1] + boomArray[x - 1][y - 1] + boomArray[x - 1][y] + boomArray[x - 1][y + 1] + boomArray[x] [y + 1]; &#125; mySet(x, y, num); &#125; if (y == 0 &amp;&amp; x != 0 &amp;&amp; x != boomArray.length - 1) &#123; num = boomArray[x - 1][y] + boomArray[x - 1][y + 1] + boomArray[x][y + 1] + boomArray[x + 1][y + 1] + boomArray[x + 1][y]; mySet(x, y, num); &#125; if (y == boomArray[x].length - 1 &amp;&amp; x != 0 &amp;&amp; x != boomArray.length - 1) &#123; num = boomArray[x - 1][y] + boomArray[x - 1][y - 1] + boomArray[x][y - 1] + boomArray[x + 1][y - 1] + boomArray[x + 1][y]; mySet(x, y, num); &#125; if (x != 0 &amp;&amp; x != boomArray.length - 1 &amp;&amp; y != 0 &amp;&amp; y != boomArray[x].length - 1) &#123; num = boomArray[x - 1][y - 1] + boomArray[x - 1][y] + boomArray[x - 1][y + 1] + boomArray[x][y + 1] + boomArray[x + 1][y + 1] + boomArray[x + 1][y] + boomArray[x + 1][y - 1] + boomArray[x][y - 1]; mySet(x, y, num); &#125; &#125; function mySet(x, y, num) &#123; allRow[x].children[y].childNodes[0].setAttribute(\"value\", num); allRow[x].children[y].childNodes[0].setAttribute(\"disabled\", \"disabled\"); allRow[x].children[y].childNodes[0].setAttribute(\"class\", \"safe\"); &#125; function createOperat() &#123; btn1.setAttribute(\"type\", \"button\"); btn1.setAttribute(\"value\", \"重置\"); btn1.setAttribute(\"onclick\", \"reset()\"); btn2.setAttribute(\"type\", \"button\"); btn1.setAttribute(\"class\", \"operat\"); btn2.setAttribute(\"value\", \"显示所有格子\"); btn2.setAttribute(\"onclick\", \"showAllTd()\"); btn2.setAttribute(\"class\", \"operat\"); &#125; function reset() &#123; location.reload(); &#125; function showAllTd() &#123; for (var i = 0; i &lt; YLen; i++) &#123; for (var j = 0; j &lt; XLen; j++) &#123; allRow[i].children[j].childNodes[0].setAttribute(\"class\", \"displayAll\"); allRow[i].children[j].childNodes[0].setAttribute(\"value\", boomArray[i][j]); &#125; &#125; &#125;&lt;/script&gt; 第二版第二版在第一版的基础上增加了显示剩余安全块的功能和设置雷的个数的功能 效果： **主要思路和第一版是一样的，不一样的地方是table标签里的表格使用创建节点的方式创建的** 剩余安全块：用格子总个数 - 雷的个数，然后每点一下不是雷就减一 设置雷数：当点击了确定后将原有的表格里的所有子节点删除，再重新往table标签里添加表格，并重新生成雷的个数。 代码HTML5+CSS部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;扫雷&lt;/title&gt; &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; h2&#123; text-align: center; padding-top: 20px; &#125; .content&#123; margin: 20px auto 0 auto; width: 450px; /* height: 500px; */ &#125; .tip&#123; display: flex; justify-content: space-around; align-items: center; &#125; #notBoomNum[type=\"text\"]&#123; text-align: center; &#125; table&#123; width: 100%; height: 450px; text-align: center; &#125; #operat&#123; display: flex; justify-content: center; width: 450px; margin: 10px auto; /* border: 1px solid #000; */ &#125; .operat&#123; background-color: red; margin: 0 auto; width: 50px; height: 30px; &#125; input&#123; width: 100%; height: 100%; border: none; &#125; #notBoomNum&#123; width: 2em; height: 2em; /* border: 1px solid #999; */ background-color: rgba(0, 0, 0, 0); font-size: 1.5em; margin-bottom: 10px; height: 1.5em; &#125; #setBoom&#123; width: 55%; position: relative; &#125; #showTd&#123; display: inline-block; &#125; #setValue&#123; border: 1px solid #999; width: 6em; height: 2em; &#125; #setBtn&#123; position: absolute; right: 0%; top: 0%; width: 20%; background-color: #999; &#125; #setBtn:hover&#123; background-color: orangered; color: #fff; &#125; td&#123; width: 10px; height: 10px; &#125; .safe&#123; background-color: limegreen; color: #fff; &#125; .bomb&#123; background-color: darkred; &#125; .displayAll&#123; background-color: darkorange; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;扫雷&lt;/h2&gt; &lt;div class=\"content\"&gt; &lt;span class=\"tip\"&gt; &lt;div id=\"showTd\"&gt; 剩余安全格子： &lt;input type=\"text\" id=\"notBoomNum\" disabled=\"disabled\"/&gt; &lt;/div&gt; &lt;div id=\"setBoom\"&gt; &lt;div class=\"setBoom-input\"&gt;设置雷的数量：&lt;input type=\"text\" id=\"setValue\" placeholder=\"默认值：20\" /&gt;&lt;/div&gt; &lt;input type=\"button\" id=\"setBtn\" value=\"确定\" /&gt; &lt;/div&gt; &lt;/span&gt; &lt;table border=\"1\" id=\"tab\"&gt;&lt;/table&gt; &lt;/div&gt; &lt;div id=\"operat\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; JavaScript部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194&lt;script type=\"text/javascript\"&gt; window.onload = tableInit; var opera = document.getElementById('operat'); var btn1 = document.createElement('input'); var btn2 = document.createElement('input'); //没有雷的格子数量 var notBoomNum = 0; var x = 0; var y = 0; //正方形表格的边的格子数 var edgeLattice = 10; //雷的数量 var boomNum = 20; // 用于存放雷的数组 var boomArray = new Array(edgeLattice); var XLen = 0; var YLen = 0; for (var i = 0; i &lt; boomArray.length; i++) &#123; boomArray[i] = new Array(10); &#125; XLen = boomArray[0].length; YLen = boomArray.length; notBoomNum = (XLen * YLen) - boomNum; console.log(\"共\" + XLen * YLen + \"个格子\"); console.log(\"一共有\" + boomNum + \"个雷\"); //初始化雷的个数 setBoom(boomNum); createOperat(); opera.appendChild(btn1); var allRow = document.getElementsByTagName('tr'); function inputInit() &#123; for (var i = 0; i &lt; YLen; i++) &#123; for (var j = 0; j &lt; XLen; j++) &#123; var thisBtn = document.createElement('input'); thisBtn.setAttribute(\"type\", \"button\"); thisBtn.setAttribute(\"value\", \" \"); thisBtn.setAttribute(\"onclick\", \"isBoom(\" + i + \",\" + j + \")\"); allRow[i].children[j].appendChild(thisBtn); &#125; &#125; &#125; function setBoom(boom_number) &#123; boomNum = boom_number; notBoomNum = (XLen * YLen) - boomNum; var count = 0; var x = 0; var y = 0; for (var i = 0; i &lt; boomArray.length; i++) &#123; for (var j = 0; j &lt; boomArray[i].length; j++) &#123; boomArray[i][j] = 0; &#125; &#125; //随机数生成boomNum个雷 while (count &lt; boom_number) &#123; x = Math.ceil(Math.random() * (YLen)) - 1; y = Math.ceil(Math.random() * (XLen)) - 1; //防止类的位置重复 if (boomArray[x][y] == 0) &#123; boomArray[x][y] = 1; count++; &#125; &#125; setTip(); &#125; function isBoom(x, y) &#123; // var = oldBoomNum = boomNum; // if(boomNum &lt;) var td = boomArray[x][y]; if (td != 1) &#123; notBoomNum--; showBoom(x, y); setTip(); if (notBoomNum == 0) &#123; alert(\"恭喜您，成功通关！\"); location.reload(); &#125; &#125; else &#123; alert(\"BOOM!!! Game Over！\"); showAllTd(); &#125; &#125; function showBoom(x, y) &#123; var num = 0; if (x == 0) &#123; if (y == 0) num = boomArray[0][1] + boomArray[1][1] + boomArray[1][0]; else if (y == boomArray[x].length - 1) num = boomArray[0][y - 1] + boomArray[x + 1][y - 1] + boomArray[x + 1][y]; else &#123; num = boomArray[x][y - 1] + boomArray[x + 1][y - 1] + boomArray[x + 1][y] + boomArray[x + 1][y + 1] + boomArray[x] [y + 1]; &#125; mySet(x, y, num); console.log(num); &#125; if (x == (boomArray.length - 1)) &#123; if (y == 0) num = boomArray[x - 1][0] + boomArray[x - 1][1] + boomArray[x][y + 1]; else if (y == boomArray[x].length - 1) num = boomArray[x][y - 1] + boomArray[x - 1][y - 1] + boomArray[x - 1][y]; else &#123; num = boomArray[x][y - 1] + boomArray[x - 1][y - 1] + boomArray[x - 1][y] + boomArray[x - 1][y + 1] + boomArray[x] [y + 1]; &#125; mySet(x, y, num); &#125; if (y == 0 &amp;&amp; x != 0 &amp;&amp; x != boomArray.length - 1) &#123; num = boomArray[x - 1][y] + boomArray[x - 1][y + 1] + boomArray[x][y + 1] + boomArray[x + 1][y + 1] + boomArray[x + 1][y]; mySet(x, y, num); &#125; if (y == boomArray[x].length - 1 &amp;&amp; x != 0 &amp;&amp; x != boomArray.length - 1) &#123; num = boomArray[x - 1][y] + boomArray[x - 1][y - 1] + boomArray[x][y - 1] + boomArray[x + 1][y - 1] + boomArray[x + 1][y]; mySet(x, y, num); &#125; if (x != 0 &amp;&amp; x != boomArray.length - 1 &amp;&amp; y != 0 &amp;&amp; y != boomArray[x].length - 1) &#123; num = boomArray[x - 1][y - 1] + boomArray[x - 1][y] + boomArray[x - 1][y + 1] + boomArray[x][y + 1] + boomArray[x + 1][y + 1] + boomArray[x + 1][y] + boomArray[x + 1][y - 1] + boomArray[x][y - 1]; mySet(x, y, num); &#125; &#125; function mySet(x, y, num) &#123; allRow[x].children[y].childNodes[0].setAttribute(\"value\", num); allRow[x].children[y].childNodes[0].setAttribute(\"disabled\", \"disabled\"); allRow[x].children[y].childNodes[0].setAttribute(\"class\", \"safe\"); &#125; function createOperat() &#123; btn1.setAttribute(\"type\", \"button\"); btn1.setAttribute(\"value\", \"重置\"); btn1.setAttribute(\"onclick\", \"reset()\"); btn2.setAttribute(\"type\", \"button\"); btn1.setAttribute(\"class\", \"operat\"); btn2.setAttribute(\"value\", \"显示所有格子\"); btn2.setAttribute(\"onclick\", \"showAllTd()\"); btn2.setAttribute(\"class\", \"operat\"); &#125; function reset() &#123; location.reload(); &#125; function showAllTd() &#123; for (var i = 0; i &lt; YLen; i++) &#123; for (var j = 0; j &lt; XLen; j++) &#123; allRow[i].children[j].childNodes[0].setAttribute(\"class\", \"displayAll\"); allRow[i].children[j].childNodes[0].setAttribute(\"value\", boomArray[i][j]); &#125; &#125; &#125; function tableInit() &#123; var tab = document.getElementById('tab'); for (var i = 0; i &lt; XLen; i++) &#123; var tr = document.createElement('tr'); console.log(tr); tab.appendChild(tr); for (var j = 0; j &lt; YLen; j++) &#123; var td = document.createElement('td'); tr.appendChild(td); &#125; &#125; inputInit(); &#125; function setTip() &#123; var tip = document.getElementById('notBoomNum'); tip.setAttribute('value', notBoomNum); &#125; function clearTable() &#123; var tab = document.getElementById('tab'); var childs = tab.childNodes; for (var i = childs.length - 1; i &gt;= 0; i--) &#123; tab.removeChild(tab.childNodes[i]); &#125; &#125; document.getElementById('setBtn').onclick = function() &#123; var value = document.getElementById('setValue').value || 20; boom_num = value; setBoom(boom_num); console.log(boomNum + '---'); clearTable(); tableInit(); setTip(); &#125;&lt;/script&gt; 试玩试玩","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://houyang99.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://houyang99.github.io/tags/JavaScript/"}]},{"title":"记录我在Mooc上的代码","slug":"记录我在Mooc上的代码","date":"2019-11-23T14:43:42.000Z","updated":"2021-02-14T11:22:16.338Z","comments":true,"path":"2019/11/23/记录我在Mooc上的代码/","link":"","permalink":"https://houyang99.github.io/2019/11/23/%E8%AE%B0%E5%BD%95%E6%88%91%E5%9C%A8Mooc%E4%B8%8A%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"面向对象程序设计——Java语言[翁恺]课程代码记录大一学习了一年的Java，本以为学校会一直以Java为核心开展教学任务，然而到了大二，后端语言已经从Java换成了PHP，虽然都是后端语言，但不知为何对Java颇有怀恋，于是又来到了翁恺老师的Java课。其实一共有两门Java课程，分别是 零基础学Java语言 和面向对象程序设计，毕竟已经学了一年，所有基础部分的课程就没有看了，直接来到了面向对象程序设计 于是就在某一年的某个月某一天2019年11月23日 把之前部署在Github上的HEXO博客又重新部署了一遍，想着在课余时间把自己学习的Java代码做一个记录，所以就有了这一篇博客~ ### 第一周编程题 -- 分数","text":"面向对象程序设计——Java语言[翁恺]课程代码记录大一学习了一年的Java，本以为学校会一直以Java为核心开展教学任务，然而到了大二，后端语言已经从Java换成了PHP，虽然都是后端语言，但不知为何对Java颇有怀恋，于是又来到了翁恺老师的Java课。其实一共有两门Java课程，分别是 零基础学Java语言 和面向对象程序设计，毕竟已经学了一年，所有基础部分的课程就没有看了，直接来到了面向对象程序设计 于是就在某一年的某个月某一天2019年11月23日 把之前部署在Github上的HEXO博客又重新部署了一遍，想着在课余时间把自己学习的Java代码做一个记录，所以就有了这一篇博客~ ### 第一周编程题 -- 分数 我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); Fraction a = new Fraction(in.nextInt(), in.nextInt()); Fraction b = new Fraction(in.nextInt(),in.nextInt()); a.print(); b.print(); a.plus(b).print(); a.multiply(b).plus(new Fraction(5,6)).print(); a.print(); b.print(); in.close(); &#125;&#125;class Fraction&#123; private int a; private int b; Fraction(int a, int b) &#123; this.a = a; this.b = b; &#125; double toDouble()&#123; return (double)a/b; &#125;// 将自己的分数和r的分数相加，产生一个新的Fraction的对象。注意小学四年级学过两个分数如何相加的哈。 Fraction plus(Fraction r)&#123; return new Fraction(this.a * r.b + this.b * r.a, this.b * r.b); &#125;// 将自己的分数和r的分数相乘，产生一个新的Fraction的对象。 Fraction multiply(Fraction r)&#123; return new Fraction(r.a * this.a,r.b * this.b); &#125;// 将自己以“分子/分母”的形式输出到标准输出，并带有回车换行。如果分数是1/1，应该输出1。当分子大于分母时，不需要提出整数部分，即31/30是一个正确的输出。 void print()&#123; if(a == b)&#123; System.out.println(1); &#125; &#125;&#125; 第二周编程题 – 有秒计时的数字时钟 先贴一下视频里的代码大概： UML: Display 12345678910111213141516171819public class Display &#123; private int value = 0; private int limit = 0; public Display( int limit )&#123; this.limit = limit; &#125; public void increase()&#123; value ++; if( value == limit )&#123; value = 0; &#125; &#125; public int getValue()&#123; return value; &#125;&#125; Clock 123456789101112131415161718192021package com.mooc.java2;public class Clock &#123; private Display hour = new Display(24); private Display minute = new Display(60); public void start()&#123; while(true) &#123; minute.increase(); if (minute.getValue() == 0) &#123; hour.increase(); &#125; System.out.printf(\"%02d : %02d\\n\", hour.getValue(), minute.getValue()); &#125; &#125; public static void main(String[] args) &#123; Clock clock = new Clock(); clock.start(); &#125;&#125; 运行结果 下面放上这周的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import static java.lang.String.format;class Display &#123; private int value = 0; private int limit = 0; public Display(int limit) &#123; this.limit = limit; &#125; public void increase() &#123; value++; if (value == limit) &#123; value = 0; &#125; &#125; public void setValue(int value) &#123; this.value = value; &#125; public int getValue() &#123; return value; &#125;&#125;class Clock &#123; private Display hour = new Display(24); private Display minute = new Display(60); private Display second = new Display(60); public Clock(int hour, int minute, int second) &#123; this.hour.setValue(hour); this.minute.setValue(minute); this.second.setValue(second); &#125; public void tick() &#123; second.increase(); if (second.getValue() == 0) &#123; minute.increase(); if (minute.getValue() == 0) &#123; hour.increase(); &#125; &#125; &#125; public String toString() &#123; String ret = format(\"%02d:%02d:%02d\", hour.getValue(), minute.getValue(), second.getValue()); return ret; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; java.util.Scanner in = new java.util.Scanner(System.in); Clock clock = new Clock(in.nextInt(), in.nextInt(), in.nextInt()); clock.tick(); System.out.println(clock); in.close(); &#125;&#125; 未完待续~","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"https://houyang99.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://houyang99.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"java","slug":"java","permalink":"https://houyang99.github.io/tags/java/"},{"name":"mooc","slug":"mooc","permalink":"https://houyang99.github.io/tags/mooc/"}]},{"title":"MySQL 2019年5月13日 学习记录","slug":"2019-5-13-MySQL-procedure-function","date":"2019-05-13T12:38:59.000Z","updated":"2021-02-14T11:22:16.315Z","comments":true,"path":"2019/05/13/2019-5-13-MySQL-procedure-function/","link":"","permalink":"https://houyang99.github.io/2019/05/13/2019-5-13-MySQL-procedure-function/","excerpt":"本周一，我们又学习了MySQL的存储过程和存储函数的创建和调用。 首先是存储过程 语法： 小练习： 有一些数据： 学号姓名性别专业1001张三男计算机应用技术1002李四男计算机应用技术2001赵丽女多媒体技术3001王军男应用电子技术4004杨洋男楼宇智能化技术5010谢楠楠女计算机网络技术 题目：创建一个存储过程，并求出表中指定专业的学生人数。 这里提前准备了数据","text":"本周一，我们又学习了MySQL的存储过程和存储函数的创建和调用。 首先是存储过程 语法： 小练习： 有一些数据： 学号姓名性别专业1001张三男计算机应用技术1002李四男计算机应用技术2001赵丽女多媒体技术3001王军男应用电子技术4004杨洋男楼宇智能化技术5010谢楠楠女计算机网络技术 题目：创建一个存储过程，并求出表中指定专业的学生人数。 这里提前准备了数据 代码： delimiter // create procedure num_proc(in s_major varchar(20),out num int) begin select count(*) into num from stu_info where stu_info.major=s_major; end// 下面来测试一下： call num_proc(‘计算机应用技术’,@n); select @n; 结果： 未完待续……","categories":[{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://houyang99.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://houyang99.github.io/tags/MySQL/"},{"name":"学习记录","slug":"学习记录","permalink":"https://houyang99.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"我的第一篇Hexo Blog","slug":"我的第一篇Blog","date":"2019-05-11T14:23:29.000Z","updated":"2021-02-14T11:22:16.337Z","comments":true,"path":"2019/05/11/我的第一篇Blog/","link":"","permalink":"https://houyang99.github.io/2019/05/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87Blog/","excerpt":"","text":"今天，第一次将Hexo搭建起来了并且部署到了 Github 上，当时的心情，无疑是非常激动的…… 第一章 参考","categories":[],"tags":[]},{"title":"MySQL数据库-触发器小练习","slug":"MySQL-trigger","date":"2019-05-09T15:37:02.000Z","updated":"2021-02-14T11:22:16.323Z","comments":true,"path":"2019/05/09/MySQL-trigger/","link":"","permalink":"https://houyang99.github.io/2019/05/09/MySQL-trigger/","excerpt":"本周，数据库上到了触发器（已经上完了），于是老师想我们分享了他之前的一篇小论文，讲的是触发器在商城里的应用—利用触发器来模拟用户在进行下单、修改订单、退货操作之后相关商品信息的变化。 首先，让我们来假设一下：现在我们有一些商品，如表 商品编号（Product id） 商品名称（Product name） 数量（Number） 1 单反 30 2 自行车 20 3 笔记本 15 下面，就开始将结构在数据库中搭建起来吧！","text":"本周，数据库上到了触发器（已经上完了），于是老师想我们分享了他之前的一篇小论文，讲的是触发器在商城里的应用—利用触发器来模拟用户在进行下单、修改订单、退货操作之后相关商品信息的变化。 首先，让我们来假设一下：现在我们有一些商品，如表 商品编号（Product id） 商品名称（Product name） 数量（Number） 1 单反 30 2 自行车 20 3 笔记本 15 下面，就开始将结构在数据库中搭建起来吧！ 创建数据库并使用数据库 创建商品信息表 下面将商品信息录入productInfo表 由于商品名称是中文，所以在录入信息前要将编码设置为gbk 查看表productInfo 太晚了……先睡觉😜（2019年5月9日23点38分） （2019年5月12日16点31分）是的，我又回来了，那么接下来干什么呢？ 首先，要模拟一个用户下单的操作：当用户下单时，productInfo表中对应的商品应该减少购买的件数，而此时对应的订单表就应该记录下来对应商品购买的件数。 那么，订单表呢？ ——好吧，我们先来建一个订单表，结构如下： 订单编号（Order id） 商品编号（Product id） 数量（number） 用户下单时，orders表就要添加相应信息，那么就可以用Insert触发器来进行操作： 测试：假设我们购买了单反5台 查看productInfo表和orders表： 可以看到对应的商品信息发生了改变","categories":[{"name":"MySQL笔记","slug":"MySQL笔记","permalink":"https://houyang99.github.io/categories/MySQL%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://houyang99.github.io/tags/MySQL/"},{"name":"学习记录","slug":"学习记录","permalink":"https://houyang99.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"Mooc-零基础学Java语言（翁恺）第四周编程题","slug":"Mooc-java-four","date":"2019-04-14T12:43:06.000Z","updated":"2021-02-14T11:22:16.317Z","comments":true,"path":"2019/04/14/Mooc-java-four/","link":"","permalink":"https://houyang99.github.io/2019/04/14/Mooc-java-four/","excerpt":"不知从何时起，这网站我就没再管了，一直到这个星期周末… 在寝室实在无聊，中午起来，便看到室友在学习了，嗯，我就是那样，只要旁边有人在学习，我自身的学习欲望就变得愈加变大，于是还是和之前一样，去了中国大学Mooc，专门来到了翁恺的课程，点开了其实已经看过了的Java基础课程，当然这是最新的一次开课，之前看完了以前的，但没开课就做不了题目（提交不了)所以便看了看题目： 第四周编程题1 首先是这个题，题目读了一遍便开始试着写了，第一次写的时候，便把需求搞错了，明明是第n个素数到第m个素数，却一气呵成的写成了n–m之间的素数，嗯，读题的时候还特意看了眼“注意”，却还是在写的时候“没按套路出牌” emmm…… 对于这个题目，我的思路是： 因为第一个素数就是2，所以循环从2开始，以后每找到一个素数，计数器+1，当计数器 n ≤ count ≤ m 时，这个素数也必然就是我要找的数了 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class Main &#123;/* 题目内容： 我们认为2是第一个素数，3是第二个素数，5是第三个素数，依次类推。 现在，给定两个整数n和m，0&lt;n&lt;=m&lt;=200，你的程序要计算第n个素数到第m个素数之间所有的素数的和 包括第n个素数和第m个素数。 注意，是第n个素数到第m个素数之间的所有的素数，并不是n和m之间的所有的素数。 输入格式: 两个整数，第一个表示n，第二个表示m。 输出格式： 一个整数，表示第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。 输入样例： 2 4 输出样例： 15 */ public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int m,n,sum = 0,count = 0; n = in.nextInt(); m = in.nextInt(); for( int i = 2;count&lt;=m; i++ ) &#123; if( isPrime(i) ) &#123; count ++; if( count &gt;= n &amp;&amp; count &lt;= m ) &#123; sum += i; &#125; &#125; &#125; System.out.println(sum); &#125; public static boolean isPrime( int num ) &#123; boolean ret = false; int i; for( i = 2; i &lt; num; i++ ) &#123; if( num%i == 0) &#123; break; &#125; &#125; if( i == num ) &#123; ret = true; &#125; return ret; &#125;&#125; &#123;% endcodeblock %&#125; 结果：","text":"不知从何时起，这网站我就没再管了，一直到这个星期周末… 在寝室实在无聊，中午起来，便看到室友在学习了，嗯，我就是那样，只要旁边有人在学习，我自身的学习欲望就变得愈加变大，于是还是和之前一样，去了中国大学Mooc，专门来到了翁恺的课程，点开了其实已经看过了的Java基础课程，当然这是最新的一次开课，之前看完了以前的，但没开课就做不了题目（提交不了)所以便看了看题目： 第四周编程题1 首先是这个题，题目读了一遍便开始试着写了，第一次写的时候，便把需求搞错了，明明是第n个素数到第m个素数，却一气呵成的写成了n–m之间的素数，嗯，读题的时候还特意看了眼“注意”，却还是在写的时候“没按套路出牌” emmm…… 对于这个题目，我的思路是： 因为第一个素数就是2，所以循环从2开始，以后每找到一个素数，计数器+1，当计数器 n ≤ count ≤ m 时，这个素数也必然就是我要找的数了 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class Main &#123;/* 题目内容： 我们认为2是第一个素数，3是第二个素数，5是第三个素数，依次类推。 现在，给定两个整数n和m，0&lt;n&lt;=m&lt;=200，你的程序要计算第n个素数到第m个素数之间所有的素数的和 包括第n个素数和第m个素数。 注意，是第n个素数到第m个素数之间的所有的素数，并不是n和m之间的所有的素数。 输入格式: 两个整数，第一个表示n，第二个表示m。 输出格式： 一个整数，表示第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。 输入样例： 2 4 输出样例： 15 */ public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int m,n,sum = 0,count = 0; n = in.nextInt(); m = in.nextInt(); for( int i = 2;count&lt;=m; i++ ) &#123; if( isPrime(i) ) &#123; count ++; if( count &gt;= n &amp;&amp; count &lt;= m ) &#123; sum += i; &#125; &#125; &#125; System.out.println(sum); &#125; public static boolean isPrime( int num ) &#123; boolean ret = false; int i; for( i = 2; i &lt; num; i++ ) &#123; if( num%i == 0) &#123; break; &#125; &#125; if( i == num ) &#123; ret = true; &#125; return ret; &#125;&#125; &#123;% endcodeblock %&#125; 结果： 接下来，就是第2题了： 对于这个题目来说，我实现了题目的要求，但是只得了3分（满分5分） 有没有大佬出来给出一份最佳的代码... 我目前的思路，是用一个数组 py 存放0~9的拼音，然后将每一位的值放到另一个数组 nums 里，输出的时候输出py[num[i]] . 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class duNum &#123;/* 题目内容： 你的程序要读入一个整数，范围是[-100000,100000]。然后，用汉语拼音将这个整数的每一位输出出来。 如输入1234，则输出： yi er san si 注意，每个字的拼音之间有一个空格，但是最后的字后面没有空格。当遇到负数时，在输出的开头加上“fu”， 如-2341输出为： fu er san si yi 输入格式: 一个整数，范围是[-100000,100000]。 输出格式： 表示这个整数的每一位数字的汉语拼音，每一位数字的拼音之间以空格分隔，末尾没有空格。 输入样例： -30 输出样例： fu san ling */ public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String[] py = &#123;\"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\"&#125;; int num = in.nextInt(); int i = 0; if(num&lt;0) &#123; System.out.print(\"fu \"); num = num * -1; &#125; int len = (\"\"+num).length(); int[] nums = new int[len]; while(num%10 != 0) &#123; nums[len-i-1] = num%10; num /= 10; i++; &#125; for( i = 0; i &lt; len; i++ ) &#123; System.out.print(py[nums[i]]); if( i &lt; len-1 ) &#123; System.out.print(\" \"); &#125; &#125; &#125;&#125; 测试结果： 正数测试结果 负数测试结果","categories":[{"name":"Java笔记","slug":"Java笔记","permalink":"https://houyang99.github.io/categories/Java%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Mooc","slug":"Mooc","permalink":"https://houyang99.github.io/tags/Mooc/"},{"name":"Java","slug":"Java","permalink":"https://houyang99.github.io/tags/Java/"}]}]}